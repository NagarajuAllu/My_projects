<?xml version="1.0" encoding="UTF-8" ?>
<script filenameHash="5eafbf4b3eab6deb8fed4892355b5192" versionHash="a87ff679a2f3e71d9181a67b7542122c" name="processSTC.writeSequenceForBundlesInOrder">
  <label>Write Sequence For Bundles In Order</label>
  <metaVersion>4</metaVersion>
  <parameterList>
    <parameter name="bundleOrder" type="rifp">
      <type>order_ds_ws.bundleOrderSTC</type>
    </parameter>
  </parameterList>
  <script><![CDATA[
    var sequence                = 1;
    var priority                = 1;
    var child_processed         = 0;
    var count_processed_in_loop = 0;
    var errorFound              = null;
    var exceptionFound          = null;
    var found_record_with_higher_priority = false;

    try {
        while(child_processed < bundleOrder.bundles.length  && errorFound == null ) {
            count_processed_in_loop = 0;
            found_record_with_higher_priority = false;

            for(var i=0; i<bundleOrder.bundles.length && errorFound == null; i++) {
                var isProvisionable = (!processSTC.isLineItemCompleted(bundleOrder.bundles[i].bundle.lineItemStatus) &&
                                       ds_ws.isLegacyService(bundleOrder.bundles[i]) &&
                                       ds_ws.checkIfServiceTypeAllowsProvisioning(bundleOrder.bundles[i].bundle.serviceType) &&
                                       bundleOrder.bundles[i].bundle.action != 'N');
                if(bundleOrder.bundles[i].bundle.priority == priority) {
                    // priority is good; checking if already processed
                    if(! processSTC.existRecordInOrchestrationTable(bundleOrder.bundles[i].bundle.id)) {
                        // to be processed; checking if has dependencies
                        if(bundleOrder.bundles[i].bundle.dependencies == null || bundleOrder.bundles[i].bundle.dependencies.length == 0) {
                            // no dependencies ==> add record to table
                            processSTC.writeRecordForLineItemInOrchestrationTable(bundleOrder.orderHeader.orderNumber,
                                                                                  bundleOrder.id,
                                                                                  bundleOrder.id,
                                                                                  sequence,
                                                                                  isProvisionable,
                                                                                  bundleOrder.bundles[i].bundle,
                                                                                  'B');
                            child_processed++;
                            count_processed_in_loop++;
                            errorFound = processSTC.writeSequenceForCircuitsInOrder(bundleOrder, bundleOrder.bundles[i]);
                        }
                        else {
                            // there are dependencies; checking if already processed
                            var all_dependencies_processed = true;
                            var dependencies = bundleOrder.bundles[i].bundle.dependencies.split(";");
                            for(var j=0; j<dependencies.length && all_dependencies_processed; j++) {
                                // check if the dependencies is in table; if yes, continue, otherwise stop;
                                var recordInOrchestrationTable = processSTC.getRecordInOrchTabByItemIdentifier_OrdNum_CwOrdId(bundleOrder.orderHeader.orderNumber, bundleOrder.id, dependencies[j]);
                                if(recordInOrchestrationTable != null) {
                                    if(recordInOrchestrationTable.elementTypeInOrchestration != 'B') {
                                        // Error in orchestration: element {0} depends on a not sibling element: {1}
                                        exceptionFound = "AE0032";
                                        Global.throwException(Global.translateText("AE0032", null, [bundleOrder.bundles[i].bundle.lineItemIdentifier, dependencies[j]]));
                                    }

                                    if(!recordInOrchestrationTable.provisionable) {
                                        // Error in orchestration: element {0} depends on a non provisionable element: {1}
                                        exceptionFound = "AE0033";
                                        Global.throwException(Global.translateText("AE0033", null, [bundleOrder.bundles[i].bundle.lineItemIdentifier, dependencies[j]]));
                                    }

                                    // checking that the current element has a higher sequence that the dependency
                                    all_dependencies_processed = (recordInOrchestrationTable.sequence < sequence);
                                }
                                else {
                                    all_dependencies_processed = false;
                                }
                            }

                            if(all_dependencies_processed) {
                                // all dependencies have been already processed ==> add record to table
                                processSTC.writeRecordForLineItemInOrchestrationTable(bundleOrder.orderHeader.orderNumber,
                                                                                      bundleOrder.id,
                                                                                      bundleOrder.id,
                                                                                      sequence,
                                                                                      isProvisionable,
                                                                                      bundleOrder.bundles[i].bundle,
                                                                                      'B');
                                child_processed++;
                                count_processed_in_loop++;
                                errorFound = processSTC.writeSequenceForCircuitsInOrder(bundleOrder, bundleOrder.bundles[i]);
                            }
                        }
                    }
                    else {
                        // already processed, so skipped
                    }
                }
                else {
                    // priority is different
                    if(!found_record_with_higher_priority) {
                        found_record_with_higher_priority = (bundleOrder.bundles[i].bundle.priority > priority);
                    }
                }
            } // end for

            if(count_processed_in_loop == 0) {
                // found no processable record in the for
                if(found_record_with_higher_priority) {
                    // but found a child with higher priority, so increase the priority
                    priority++
                }
                else {
                    errorFound = new DataStructure("ds_ws:OrderFailure");
                    errorFound.ErrorCode = "AE0030";
                    errorFound.ErrorDescription = Global.translateText("AE0030", null, bundleOrder.orderHeader.orderNumber);
                    errorFound.ErrorTime = common.common_currentDateAsStringDDMMYYYYHH24MISS();
                    errorFound.ErrorType = "VALIDATION ERROR";
                    errorFound.FunctionName = "SUBMIT ORDER";
                    errorFound.ObjectId = bundleOrder.orderHeader.orderNumber;
                    errorFound.SystemName = "Workflow Director";
                }
            }
            else {
                // increasing the sequence because a new loop has to start
                sequence++;
            }
        }  // end while
    }
    catch(exc) {
        errorFound = new DataStructure("ds_ws:OrderFailure");
        errorFound.ErrorCode = exceptionFound;
        errorFound.ErrorDescription = exc.message;
        errorFound.ErrorTime = common.common_currentDateAsStringDDMMYYYYHH24MISS();
        errorFound.ErrorType = "VALIDATION ERROR";
        errorFound.FunctionName = "SUBMIT ORDER";
        errorFound.ObjectId = bundleOrder.orderHeader.orderNumber;
        errorFound.SystemName = "Workflow Director";
    }
    return errorFound;
  ]]></script>
</script>