<?xml version="1.0" encoding="UTF-8" ?>
<script filenameHash="bbe68cba8b6f8480529d67ca876a4099" versionHash="a87ff679a2f3e71d9181a67b7542122c" name="ds_ws.updateExistingOrderForResubmit">
  <label>Update Existing Order For Resubmit</label>
  <metaVersion>4</metaVersion>
  <parameterList>
    <parameter name="existingOrder" type="rifp">
      <type>order_ds_ws.bundleOrderSTC</type>
    </parameter>
    <parameter name="receivedInputMsg" type="rifp">
      <type>dstruct_ds_ws.submitOrder</type>
    </parameter>
  </parameterList>
  <script><![CDATA[
    var validationErrors = null;
    var failureArray = null;


    // generating the temporary order for received data
    var orderForReceivedData = ds_ws.mappingIncomingDSIntoBundleOrder(receivedInputMsg, true, false);
    if(orderForReceivedData == null) {
        validationErrors = ds_ws.appendToValidationErrors("AE0035", Global.translateText("AE0035"), validationErrors, "updateExistingOrderForResubmit (" + existingOrder.orderHeader.orderNumber + ")");
    }
    else {
        // update orderHeader of the existing order with the data received
        failureArray = ds_ws.updateExistingOrderHeaderForResubmit(existingOrder, orderForReceivedData, failureArray);

        // bundle check; it loops in bundle of existing order and verifies if it exists also in received one
        if(existingOrder.bundles != null) {
            var missingReceived = 0;
            for(var i=0; i<existingOrder.bundles.length; i++) {
                var existingLineItem = existingOrder.bundles[i].bundle.lineItemIdentifier;
                var found = false;
                // search bundle in received
                if(orderForReceivedData.bundles != null) {
                    for(var j=0; j<orderForReceivedData.bundles.length && !found; j++) {
                        if(existingLineItem == orderForReceivedData.bundles[j].bundle.lineItemIdentifier) {
                            // found; comparing the 2 lineItems and the entire hierarchy
                            found = true;
                            failureArray = ds_ws.updateExistingLineItemForResubmit(existingOrder.bundles[i], orderForReceivedData.bundles[j], "B", existingOrder, failureArray);
                        }
                    }
                }

                if(!found) {
                    // not found bundle; adding error
                    validationErrors = ds_ws.appendToValidationErrors("AE0067", Global.translateText("AE0067", null, existingLineItem), validationErrors, "updateExistingOrderForResubmit (" + existingOrder.orderHeader.orderNumber + ")");
                    missingReceived++;
                }
            }

            if(orderForReceivedData.bundles != null) {
                if((orderForReceivedData.bundles.length + missingReceived) != existingOrder.bundles.length) {
                    // it means that there are additional bundles in received that are not in existing! ERROR!
                    validationErrors = ds_ws.appendToValidationErrors("AE0059", Global.translateText("AE0059",  null, ["B", "existing"]), validationErrors, "updateExistingOrderForResubmit (" + existingOrder.orderHeader.orderNumber + ")");
                }
            }
        }
        else {
            if(orderForReceivedData.bundles != null) {
                // it means that there are bundles in received that are not in existing! ERROR!
                validationErrors = ds_ws.appendToValidationErrors("AE0059", Global.translateText("AE0059",  null, ["B", "existing"]), validationErrors, "updateExistingOrderForResubmit (" + existingOrder.orderHeader.orderNumber + ")");
            }
        }

        // deleting temporary order
        orderForReceivedData.deleteOrder();
    }

    if(validationErrors != null) {
        failureArray = ds_ws.addValidationErrorsToFailureArrayForSub_UpdInWD(validationErrors, existingOrder.orderHeader.orderNumber, failureArray, true);
    }


    return failureArray;
  ]]></script>
</script>